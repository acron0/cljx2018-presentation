<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/blood.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
		    <div class="slides">
                        <!-- SLIDE -->
                        <section>
                            <h1>Levelling Up<br/>
                                <highlight>Lacinia</highlight>
                                Using<br/>
                                <highlight>Spec</highlight>
                            </h1>

                            <aside class="notes">
		                <ul>
                                    <li>(Turn off alarms)</li>
                                    <li>Hello</li>
                                    <li>Thanks</li>
                                    <li>First ClojureX</li>
                                    <li>Too many slides</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <h2>Antony Woods</h2>
                            <img class="naked headshot" src="img/acron.png"/>
                            <div>
                                <div>https://github.com/acron0</div>
                                <div>@acron</div>
                            </div>

                            <aside class="notes">
		                <ul>
                                    <li>Writing Clojure for 6 years</li>
                                    <li>Started by sneaking</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <img class="naked" src="img/codi.png"/>

                            <aside class="notes">
		                <ul>
                                    <li>Right now I work for...</li>
                                    <li>the name is not just posturing; We do Clojure. fullstack</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>

                            <div class="is-flex is-columns">
                                <div class="has-centered-text">
                                    <h3>Front</h3>
                                    <div><img class="naked logo" src="img/cljs.png"></div>
                                    <h4>re-frame</h4>
                                    <h4>venia</h4>
                                </div>
                                <div class="has-centered-text">
                                    <h3>Back</h3>
                                    <div><img class="naked logo" src="img/clj.png"></div>
                                    <h4>compojure</h4>
                                    <h4>lacinia</h4>
                                </div>
                            </div>

                            <div style="margin-top: 50px;">
                                <img class="naked logo" src="img/graphql.png">
                                <h4>graphql</h4>
                            </div>

                            <aside class="notes">
		                <ul>
                                    <li>Fairly standard offering</li>
                                    <li>(Describe)</li>
                                    <li>GraphQL is our tool</li>
                                    <li>Venia: GraphQL client library</li>
                                    <li>Lacinia: an implementation of the GraphQL specification</li>
                                    <li>Our fairly relational data model makes GraphQL a good fit</li>
                                </ul>
	                    </aside>
                        </section>


                        <!-- SLIDE -->
                        <section>
                            <h1>Clojure<br/><highlight>Spec</highlight></h1>

                            <aside class="notes">
		                <ul>
                                    <li>Another tool we use alot</li>
                                    <li>Few reasons</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <ul>
                                <li>Validating data</li>
                                <li class="fragment">Documentation</li>
                                <li class="fragment">Property-based testing</li>
                                <li class="fragment">Confidence</li>
                            </ul>

                            <aside class="notes">
		                <ul>
                                    <li>It's great at Validating data. No surprise here. for us mainly at boundaries. Data in and out. Did the client really send etc</li>
                                    <li>It's a useful mechanism for documenting the flow of data through the application. We add specs to functions where possible, and this helps with...</li>
                                    <li>We make extensive use of TestCheck to exercise numerous pathways through the applications; good results</li>
                                    <li>Confident in ability to change things and iterate quickly</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <img class="is-full-width" src="img/whspec.png"/>

                            <aside class="notes">
		                <ul>
                                    <li>Here is a "real" spec</li>
                                    <li>Application; massaged slightly</li>
                                    <li>My experience this is bog standard</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <img class="is-full-width" src="img/whlacinia.png"/>

                            <aside class="notes">
		                <ul>
                                    <li>So as well as validating data in and out using spec, we're also obliged to maintain a schema for Lacinia</li>
                                    <li>As you can see that: more Terse</li>
                                    <li>GraphQL only has 5 basic scalar types </li>
                                    <li>String, Float, Int, Boolean, ID</li>
                                    <li>Why do we need this? Lacinia own validation (it has no idea we're using spec) and pulling out fields when we only ask for a subset</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <h1>?</h1>
                            <aside class="notes">
		                <ul>
                                    <li>The obvious question is why do I need two schema when one is arguably a simpler version of the other?</li>
                                    <li>Overhead in maintaining not neglible</li>
                                    <li>Our specs combined are in region 1300 LOC</li>
                                    <li>Our Lacinia schema is 1000 LOC</li>
                                    <li>This is exactly the problem we've been tackling on and off for a while now</li>
                                    <li>In my mind, the solution started to form in the following way:</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <ol>
                                <li>Interfere with <highlight>Spec</highlight> as little as possible</li>
                                <li class="fragment">Reinvent as little as possible</li>
                                <li class="fragment">Orient toward GraphQL/<highlight>Lacinia</highlight></li>
                            </ol>
                            <aside class="notes">
		                <ul>


                                    <li>Spec is a cornerstone of Clojure development these days. Introducing any new wacky macros or wrapper fns will likely prevent adoption</li>
                                    <li>I am pretty lazy so I want to use existing tools to help as much as possible</li>
                                    <li>Understand what GraphQL and Lacinia are trying to do, how they do it, and build on top</li>
                                    <li>Ok, so What does that look like?</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
	                    <pre><code data-trim data-noescape>
(s/def ::id int?)
(s/def ::name string?)
(s/def ::access #{"candidate" "admin"})
;;
(s/def ::user-query (s/keys :req-un [::id]))
(s/def ::user (s/keys :req-un [::id]
                      :opt-un [::name
                               ::access]))
	                    </code></pre>
                            <aside class="notes">
		                <ul>
                                    <li>Let's start with a spec, albeit a little contrived - something that resembles a user</li>
                                    <li>Spec for a query - just requires an id</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section >
	                    <pre><code data-trim data-noescape>
(-> (leona/create)
    (leona/attach-query ::user-query ::user user-resolver)
    (leona/compile))

	                    </code></pre>

                            <pre class="fragment"><code data-trim data-noescape>
{:objects
 {:user
  {:fields
   {:id {:type (non-null Int)},
    :name {:type String},
    :access {:type :access}}}},
 :enums
 {:access {:values ["admin" "candidate"]}},
 :queries
 {:user
  {:type :user,
   :args {:id {:type (non-null Int)}},
   :resolve user-resolver}}}
	                    </code></pre>
                            <aside class="notes">
		                <ul>
                                    <li>This is how we introduce the query</li>
                                        <ul>
                                            <li>create empty data structure</li>
                                            <li>add the input spec</li>
                                            <li>add the output spec</li>
                                            <li>add the resolve fn</li>
                                        </ul>
                                    <li>(explain the parts)</li>
                                    <li>and this is the kind of result we can expect
                                        <ul>
                                            <li>user object has been placed into objects</li>
                                            <li>an access enum has been placed into enums</li>
                                            <li>and a user query has been placed into queries</li>
                                        </ul>
                                    </li>
                                    <li>resolver has been wrapped</li>
                                    <li>we use spec-tools from metosin to walk the spec</li>
                                    <li>in some cases there's inference about what types can be used</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            References
	                    <pre><code data-trim data-noescape>
(s/def ::application (s/keys :req-un [::id]))
(s/def ::applications (s/coll-of ::application))
;;
(s/def ::user (s/keys :req-un [::id]
                      :opt-un [::name
                               ::access
                               <mark>::applications</mark>]))

	                    </code></pre>
                            <pre><code data-trim data-noescape>
{:objects
 {<mark>:application {:fields {:id {:type (non-null Int)}}},</mark>
  :user
  {:fields
   {:id {:type (non-null Int)},
    :name {:type String},
    :access {:type :access},
    <mark>:applications {:type (list :application)}</mark>}}},
 :enums {:access {:values ["admin" "candidate"]}},
 :queries
 {:user
  {:type :user,
   :args {:id {:type (non-null Int)}},
   :resolve user-resolver}}}
	                    </code></pre>

                            <aside class="notes">
		                <ul>
                                    <li>Applications</li>
                                    <li>After adding a reference, if we were so inclined we could also add a ...</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section >
                            Field Resolvers
	                    <pre><code data-trim data-noescape>
(-> (leona/create)
    (leona/attach-query ::user-query ::user user-resolver)
    (leona/attach-field-resolver ::applications
                                 applications-resolver)
    (leona/compile)

	                    </code></pre>

                            <pre><code data-trim data-noescape>
:user
  {:fields
   {:id {:type (non-null Int)},
    :name {:type String},
    :access {:type :access},
    :applications {:type (list :application)
                   <mark>:resolve applications-resolver</mark>}}}

	                    </code></pre>

                            <aside class="notes">
		                <ul>
                                    <li>Field resolvers allow us to indicate that certain fields within an object should be fetched separately. This is useful for numerous reasons, but importantly it means that if that field is ommnitted from a query then no work is wasted fetching related data, only to be discarded later.</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section >
                            Mutations
	                    <pre><code data-trim data-noescape>
(-> (leona/create)
    (leona/attach-mutation ::user-mutation ::user user-mutator)
    (leona/compile)

	                    </code></pre>

                            <aside class="notes">
		                <ul>
                                    <li>??</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section >
                            Middleware
	                    <pre><code data-trim data-noescape>
(defn field-auth-fn
 [handler ctx query value]
 ;; do logic
 (handler))

(def compiled
  (-> (leona/create)
      (leona/attach-query ::user-query ::user user-resolver)
      (leona/attach-middleware field-auth-fn) ;; <--
      (leona/compile))

(leona/execute compiled "....")


                                <aside class="notes">
		                    <ul>
                                        <li>Acts like ring middleware where you're passed a handler </li>
                                        <li>In this example scenario we might check the user is authorised to view the fields they've requested and if not just abort the process and return an error</li>
                                    </ul>
	                        </aside></code></pre>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            Overrides
	                    <pre><code data-trim data-noescape>
(s/def ::weird (st/spec weird? {:type 'Boolean}))

(s/def ::foo (st/spec weird? {:description "This is a foo"}))

	                    </code></pre>

                            <aside class="notes">
		                <ul>
                                    <li>If things get really weird and a spec can't be inferred - like a predicate - then drop back to spec-tools own 'spec' fn</li>
                                    <li>Although it's worth pointing out that so far this excape hatch hasn't been required in the Functional Works code base</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <h3>;; TODO</h3><br/>
	                    <ol>
                                <li>Interfaces and Unions</li>
                                <li class="fragment">Input Objects</li>
                                <li class="fragment">Custom Scalars</li>
                            </ol>

                            <aside class="notes">
		                <ul>
                                    <li>More nuanced parts of the GraphQL toolset but allow us to write better queries.</li>
                                    <li>Currently input specs are expanded and each arg is included. Input Objects were included to reduce repetition.</li>
                                    <li>Date parse/serialize</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <p>https://github.com/acron0/leona</p>
                            <hr/>
                            <p>Questions?</p>

                            <aside class="notes">

	                    </aside>
                        </section>

		    </div>
		</div>



		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
		 // More info about config & dependencies:
                 // - https://github.com/hakimel/reveal.js#configuration
                 // - https://github.com/hakimel/reveal.js#dependencies
		        Reveal.initialize({
                            history:true,
                            controls: false,
                            controlsTutorial: false,
                            progress: false,
		            dependencies: [
			        { src: 'plugin/markdown/marked.js' },
			        { src: 'plugin/markdown/markdown.js' },
			        { src: 'plugin/notes/notes.js', async: true },
			        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
		            ]
		        });
		</script>
	</body>
</html>
