<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/blood.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
	    <div class="reveal">
                <header></header>
		    <div class="slides">
                        <!-- SLIDE -->
                        <section>
                            <h1>Levelling Up<br/>
                                <highlight>Lacinia</highlight>
                                Using<br/>
                                <highlight>Spec</highlight>
                            </h1>

                            <aside class="notes">
		                <ul>
                                    <li>(Turn off alarms)</li>
                                    <li>Hello</li>
                                    <li>Thanks</li>
                                    <li>First ClojureX</li>
                                    <li>Too many slides</li>
                                    <li>If no time for Qs then contact me</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <h2>Antony Woods</h2>
                            <img class="naked headshot" src="img/acron.png"/>
                            <div>
                                <div>https://github.com/acron0</div>
                                <div>@acron</div>
                            </div>

                            <aside class="notes">
		                <ul>
                                    <li>Writing Clojure for 6 years</li>
                                    <li>Started by sneaking</li>
                                    <li>Don't have that problem anymore tho</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section>
                            <img class="naked" src="img/functional.png"/>
                            <h4>Functional Works</h4>

                            <aside class="notes">
		                <ul>
                                    <li>Right now I work for...</li>
                                    <li>Relevant</li>
                                    <li>We do Clojure. fullstack</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">

                            <div class="is-flex is-columns">
                                <div class="has-centered-text">
                                    <h3>Front</h3>
                                    <div><img class="naked logo" src="img/cljs.png"></div>
                                    <h4>re-frame</h4>
                                    <h4>venia</h4>
                                </div>
                                <div class="has-centered-text">
                                    <h3>Back</h3>
                                    <div><img class="naked logo" src="img/clj.png"></div>
                                    <h4>compojure</h4>
                                    <h4>lacinia</h4>
                                </div>
                            </div>

                            <div style="margin-top: 50px;">
                                <img class="naked logo" src="img/graphql.png">
                                <h4>graphql</h4>
                            </div>

                            <aside class="notes">
		                <ul>
                                    <li>Fairly standard offering</li>
                                    <li>(Describe)</li>
                                    <li>GraphQL is our tool</li>
                                    <li>Our fairly relational data model makes GraphQL a good fit</li>
                                    <li>Venia: GraphQL client library</li>
                                    <li>Lacinia: an implementation of the GraphQL specification</li>
                                </ul>
	                    </aside>
                        </section>


                        <!-- SLIDE -->
                        <section data-state="header1">
                            <h1>Clojure<br/><highlight>Spec</highlight></h1>

                            <aside class="notes">
		                <ul>
                                    <li>The other tool we use alot</li>
                                    <li>Few reasons</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            <ul>
                                <li>Validating data</li>
                                <li class="fragment">Documentation</li>
                                <li class="fragment">Property-based testing</li>
                                <li class="fragment">Confidence</li>
                            </ul>

                            <aside class="notes">
		                <ul>
                                    <li>It's great at Validating data. No surprise here.</li>
                                    <li>It's a useful mechanism for documenting the flow of data through the application. We add specs to functions where possible, and this helps with...</li>
                                    <li>We make extensive use of TestCheck to exercise numerous pathways through the applications; good results</li>
                                    <li>Confident in ability to change things and iterate quickly</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            <img class="is-full-width" src="img/whspec.png"/>

                            <aside class="notes">
		                <ul>
                                    <li>Here is a "real" spec</li>
                                    <li>Application; massaged slightly</li>
                                    <li>My experience this is bog standard</li>
                                    <li>We use this and a load of other to specs validate data in and out using of the server</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            <img class="is-full-width" src="img/whlacinia.png"/>

                            <aside class="notes">
		                <ul>
                                    <li>irritatingly - we're also obliged to maintain a schema for Lacinia</li>
                                    <li>As you can see that: more Terse</li>
                                    <li>GraphQL only has 5 basic scalar types </li>
                                    <li>String, Float, Int, Boolean, ID</li>
                                    <li>Why do we need this? Lacinia own validation (it has no idea we're using spec) and pulling out fields when we only ask for a subset</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            <h1>?</h1>
                            <aside class="notes">
		                <ul>
                                    <li>Why do we need two schema when one is arguably a simpler version of the other?</li>
                                    <li>Overhead in maintaining not neglible</li>
                                    <li>Our specs combined are in region 1300 LOC</li>
                                    <li>Our Lacinia schema is 1000 LOC</li>
                                    <li>This is exactly the problem we've been tackling on and off for a while now</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section class="big-text" data-state="header1">
                            (<highlight class="yellow">leona</highlight>)
                            <aside class="notes">
		                <ul>
                                    <!-- https://gist.github.com/halgari/c17f378718cbd2fd82324002133ef678#gistcomment-2767805 -->
                                    <li>We decided to take Stuart Halloway's advice and "make a library". It's called leona.</li>
                                    <li>It's WIP but leona is designed to replace lacinia schemas with ^^ specs aaaand add some other functionality we've found useful</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
	                    <pre><code data-trim data-noescape>
(s/def ::id int?)
(s/def ::name string?)
(s/def ::access #{"candidate" "admin"})
(s/def ::user (s/keys :req-un [::id]
                      :opt-un [::name
                               ::access]))
;;
(s/def ::user-query (s/keys :req-un [::id]))
	                    </code></pre>
                            <aside class="notes">
		                <ul>
                                    <li>Let's start with a spec, albeit a little contrived - something that resembles a user</li>
                                    <li>id, name, access level</li>
                                    <li>Spec for a query - just requires an id</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            Queries
	                    <pre><code data-trim data-noescape>
(-> (leona/create)
    (leona/attach-query ::user-query ::user user-resolver)
    (leona/compile))

	                    </code></pre>

                            <pre class="fragment"><code data-trim data-noescape>
{:objects
 {:user
  {:fields
   {:id {:type (non-null Int)},
    :name {:type String},
    :access {:type :access}}}},
 :enums
 {:access {:values ["admin" "candidate"]}},
 :queries
 {:user
  {:type :user,
   :args {:id {:type (non-null Int)}},
   :resolve user-resolver}}}
	                    </code></pre>
                            <aside class="notes">
		                <ul>
                                    <li>This is how we introduce the query to leona</li>
                                    <ul>
                                        <li>create empty data structure</li>
                                        <li>add the input spec</li>
                                        <li>add the output spec</li>
                                        <li>add the resolve fn</li>
                                    </ul>
                                    <li>(explain the parts)</li>
                                    <li>and this is the kind of result we can expect
                                        <ul>
                                            <li>user object has been placed into objects</li>
                                            <li>an access enum has been placed into enums</li>
                                            <li>and a user query has been placed into queries</li>
                                        </ul>
                                    </li>
                                    <li>resolver has been wrapped</li>
                                    <li>we use spec-tools from metosin to walk the spec</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            Mutations
	                    <pre><code data-trim data-noescape>
(-> (leona/create)
    (leona/attach-mutation ::user-mutation ::user user-mutator)
    (leona/compile)

	                    </code></pre>

                            <pre class="fragment"><code data-trim data-noescape>
{:objects
 {:user
  {:fields
   {:id {:type (non-null Int)},
    :name {:type String},
    :access {:type :access}}}},
 :enums {:access {:values ["admin" "candidate"]}},
 <mark>:mutations</mark>
 {:user
  {:type :user,
   :args
   {:id {:type (non-null Int)},
    :name {:type String},
    :access {:type :access}},
   :resolve user-mutator}}}

	                    </code></pre>

                            <aside class="notes">
		                <ul>
                                    <li>mutations are structurally very similar to queries</li>
                                    <li>In some cases where a spec references another spec we can also bring that in</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            References
	                    <pre><code data-trim data-noescape>
(s/def ::application (s/keys :req-un [::id]))
(s/def ::applications (s/coll-of ::application))
;;
(s/def ::user (s/keys :req-un [::id]
                      :opt-un [::name
                               ::access
                               <mark>::applications</mark>]))

	                    </code></pre>
                            <pre><code data-trim data-noescape>
{:objects
 {<mark>:application {:fields {:id {:type (non-null Int)}}},</mark>
  :user
  {:fields
   {:id {:type (non-null Int)},
    :name {:type String},
    :access {:type :access},
    <mark>:applications {:type (list :application)}</mark>}}},
 :enums {:access {:values ["admin" "candidate"]}},
 :queries
 {:user
  {:type :user,
   :args {:id {:type (non-null Int)}},
   :resolve user-resolver}}}
	                    </code></pre>

                            <aside class="notes">
		                <ul>
                                    <li>Applications</li>
                                    <li>After adding a reference, if we were so inclined we could also add a ...</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            Field Resolvers
	                    <pre><code data-trim data-noescape>
(-> (leona/create)
    (leona/attach-query ::user-query ::user user-resolver)
    (leona/attach-field-resolver ::applications
                                 applications-resolver)
    (leona/compile)

	                    </code></pre>

                            <pre><code data-trim data-noescape>
:user
  {:fields
   {:id {:type (non-null Int)},
    :name {:type String},
    :access {:type :access},
    :applications {:type (list :application)
                   <mark>:resolve applications-resolver</mark>}}}

	                    </code></pre>

                            <aside class="notes">
		                <ul>
                                    <li>Field resolvers allow us to indicate that certain fields within an object should be fetched separately. This is useful for numerous reasons, but importantly it means that if that field is ommnitted from a query then no work is wasted fetching related data, only to be discarded later.</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            Middleware
	                    <pre><code data-trim data-noescape>
(defn field-auth-fn
 [handler ctx query value]
 ;; do logic
 (handler))

(def compiled
  (-> (leona/create)
      (leona/attach-query ::user-query ::user user-resolver)
      (leona/attach-middleware field-auth-fn) ;; <--
      (leona/compile))

(leona/execute compiled "....")


                                <aside class="notes">
		                    <ul>
                                        <li>Acts like ring middleware where you're passed a handler </li>
                                        <li>In this example scenario we might check the user is authorised to view the fields they've requested and if not just abort the process and return an error</li>
                                    </ul>
	                        </aside></code></pre>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            Overrides
	                    <pre><code data-trim data-noescape>
(s/def ::weird (st/spec weird? {:type 'Boolean}))

(s/def ::foo (st/spec weird? {:description "This is a foo"}))

	                    </code></pre>

                            <aside class="notes">
		                <ul>
                                    <li>We can infer a lot from the spec API and various core predicates but if things get  weird and a spec can't be inferred - like a predicate - then drop back to spec-tools own 'spec' fn</li>
                                    <li>In the second example we're also adding a description which will appear in the generated schema</li>
                                </ul>
	                    </aside>
                        </section>

                        <!-- SLIDE -->
                        <section data-state="header1">
                            <h3>;; TODO</h3><br/>
	                    <ol>
                                <li>Interfaces and Unions</li>
                                <li class="fragment">Input Objects</li>
                                <li class="fragment">Custom Scalars</li>
                            </ol>

                            <aside class="notes">
		                <ul>
                                    <li>More nuanced parts of the GraphQL toolset but allow us to write better queries.</li>
                                    <li>Currently input specs are expanded and each arg is included. Input Objects were included to reduce repetition.</li>
                                    <li>Instead of overrides; parse/serialize for your own types</li>
                                    <li>Mention Serene? ClojureConj - spend a lot longer talking about why a relationship between GraphQL and Spec makes sense</li>
                                </ul>
	                    </aside>
                        </section>




                        <!-- SLIDE -->
                        <section>
                            <p>https://github.com/works-hub/leona</p>
                            <p>https://github.com/acron0/cljx2018-presentation</p>
                            <hr/>
                            <p>@acron</p>
                            <p>antony@functionalworks.com</p>

                            <aside class="notes">
                                Hiring!!
	                    </aside>
                        </section>

		    </div>
		</div>



		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
		 // More info about config & dependencies:
                 // - https://github.com/hakimel/reveal.js#configuration
                 // - https://github.com/hakimel/reveal.js#dependencies
		        Reveal.initialize({
                            history:true,
                            controls: false,
                            controlsTutorial: false,
                            progress: false,
		            dependencies: [
			        { src: 'plugin/markdown/marked.js' },
			        { src: 'plugin/markdown/markdown.js' },
			        { src: 'plugin/notes/notes.js', async: true },
			        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
		            ]
		        });
		</script>
	</body>
</html>
